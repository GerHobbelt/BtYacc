%% language
C

%% ---
/* -*- C -*-
 *
 *   The banner used here should be replaced with an #ident directive if
 *   the target C compiler supports #ident directives.
 *
 *   If the skeleton is changed, the banner should be changed so that
 *   the altered version can easily be distinguished from the original.
 */

%% banner
/* -*- C -*-
 *
 *    @(#)btyaccpar, based on byacc 1.8 (Berkeley)
 *
 */
#define YYBTYACC 1



/* [i_a] */
#ifndef HAS_MSVC_2005_ISO_RTL
#if defined(_MSC_VER)
#if _MSC_VER >= 1400 /* VS.NET 2005 or above: 'fix' those deprecated functions */
#define HAS_MSVC_2005_ISO_RTL     1
#endif
#endif

#ifndef HAS_MSVC_2005_ISO_RTL
#define HAS_MSVC_2005_ISO_RTL     0
#endif

#if HAS_MSVC_2005_ISO_RTL
#pragma warning(disable : 4996)
/* Or just turn off warnings about the newly deprecated CRT functions. */
#ifndef _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_DEPRECATE
#endif
#ifndef _CRT_NONSTDC_NO_DEPRECATE
#define _CRT_NONSTDC_NO_DEPRECATE
#endif
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES     1
#endif
#endif
/* [/i_a] */




#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <assert.h>

/* [i_a] MSVC doesn't define TRUE in the expected places; do it here to make sure we got it 'right' */
#ifndef TRUE
#undef FALSE
#undef TRUE

#define FALSE 0
#define TRUE (!FALSE)
#endif

typedef short int Yshort;

%% tables

#ifdef __cplusplus
#ifndef _YACC_EXTERN_
#define _YACC_EXTERN_ "C"
#endif
#else
#ifndef _YACC_EXTERN_
#define _YACC_EXTERN_ /**/
#endif
#endif

extern _YACC_EXTERN_ Yshort yylhs[];
extern _YACC_EXTERN_ Yshort yylen[];

/* idx: current state; entry: non-zero if to reduce regardless of lookahead */
extern _YACC_EXTERN_ Yshort yydefred[];

extern _YACC_EXTERN_ Yshort yydgoto[];

/*
 * idx: current state; entry: non-zero if shifting|reducing possible
 *      in this state - in that case, yycheck[entry + lookahead] indicates
 *      whether to perform the action for this lookahead.
 */
extern _YACC_EXTERN_ Yshort yysindex[];
extern _YACC_EXTERN_ Yshort yyrindex[];

/*
 * yycindex idx: current state; entry: non-zero if shift/reduce
 *               conflicts for this state - in that case, yycheck[entry + lookahead]
 *               indicates whether there's a conflict for this lookahead
 */
extern _YACC_EXTERN_ Yshort yycindex[];
extern _YACC_EXTERN_ Yshort yycheck[];

extern _YACC_EXTERN_ Yshort yygindex[];
extern _YACC_EXTERN_ Yshort yytable[];
extern _YACC_EXTERN_ Yshort yyctable[];

#if YYDEBUG
/*
 * idx: token code; entry: spelling of token
 */
extern _YACC_EXTERN_ char const *yyname[];

extern _YACC_EXTERN_ char const *yyrule[];
#endif

%% header

#ifndef YYERRCODE
#error Make sure you '#include' the generated btyacc .h headerfile in the .Y file itself, as it defines YYERRCODE and several other constants.
#endif

/* YYPOSN is user-defined text position type. */
#ifndef YYPOSN
#define YYPOSN int

#ifdef __cplusplus
#define YYPOSN_ZERO(yyposn)     yyposn = 0
#endif
#endif /* YYPOSN */

/*
 * YYREDUCEPOSNFUNC is a overridable function with the following prototype:
 *
 *   void YYREDUCEPOSNFUNC(YYPOSN action_yyposn, YYPOSN *yyposn_stack, YYSTYPE *yylval_stack, int rule_stack_size, int stack_size, int lexed_token, YYPOSN current_yyposn, ... ** yyval ~ $$ by default ** );
 *
 * where yylval_stack[0] and yyposn_stack[0] point at the yylval/yyposn values
 * for $1 of the reduction rule, while yylval_stack[rule_stack_size - 1] and
 * yyposn_stack[rule_stack_size - 1] would point at the yylval/yyposn for $$
 * of the same rule.
 *
 * The 'stack_size' indicates the depth of the yylval/yyposn stacks, where the
 * entire stack would then span the range [rule_stack_size - 1 - stack_size]
 * to [rule_stack_size - 1].
 *
 *
 * YYREDUCEPOSNFUNC() would be able to accept an arbitrary number of parameters,
 * depending on your YYREDUCEPOSNFUNCARG define override. The default
 * YYREDUCEPOSNFUNCARG define equals the YYSTYPE value for the last reduction,
 * i.e. the $$ value for that rule.
 */
#ifdef YYREDUCEPOSNFUNC
#define YYCALLREDUCEPOSN(e)                                                                                     \
    if (reduce_posn)                                                                                            \
    {                                                                                                           \
        YYREDUCEPOSNFUNC(yyps->pos, &(yyps->psp)[1 - yyruletokencount], &(yyps->vsp)[1 - yyruletokencount],     \
                         yyruletokencount, yyps->psp - yyps->ps, yychar, yyposn, e);                            \
        reduce_posn = 0;                                                                                        \
    }

#ifndef YYREDUCEPOSNFUNCARG
#define YYREDUCEPOSNFUNCARG (yyps->val)
#endif


#define YYPOSNARG(n) (yyps->psp[1 - yyruletokencount + (n) - 1])
#define YYPOSNOUT    (yyps->pos)
#endif

/* If delete function is not defined by the user, do not delete. */
#ifndef YYDELETEVAL
#define YYDELETEVAL(v, t)
#endif

/* If delete function is not defined by the user, do not delete. */
#ifndef YYDELETEPOSN
#define YYDELETEPOSN(v, t)
#endif

#define YYEMPTY      (-1)
/* Clear any previous look-ahead token: */
#define yyclearin    (yychar = YYEMPTY)
/* Reset the parser error state to 'normal' */
#define yyerrok      (yyps->errflag = 0)


#ifndef YYSTACKGROWTH
#define YYSTACKGROWTH 32
#endif

#ifndef YYDEFSTACKSIZE
#define YYDEFSTACKSIZE 12
#endif

#ifndef YYLEXDEFSTACKSIZE
#define YYLEXDEFSTACKSIZE (32 > YYSTACKGROWTH ? 32 : YYSTACKGROWTH)
#endif

#ifndef YYTRIALSTACKGROWTH
#define YYTRIALSTACKGROWTH (4 > YYSTACKGROWTH ? 4 : YYSTACKGROWTH)
#endif


#ifdef YYDEBUG
int yydebug = 0;
#endif

int yynerrs;

/* These value/posn are taken from the lexer */
YYSTYPE yylval;
YYPOSN  yyposn;

/* These value/posn of the root non-terminal are returned to the caller */
YYSTYPE yyretlval;
YYPOSN  yyretposn;

#define YYABORT                                     \
    do                                              \
    {                                               \
        yymode = YY_EXIT_ABORT;                     \
        goto past_the_reduce_actions;               \
    } while (0)
#define YYACCEPT                                    \
    do                                              \
    {                                               \
        if (yytrial)                                \
            yymode = YY_DO_ACCEPT_RULE;             \ 
        else                                        \
            yymode = YY_EXIT_ACCEPT;                \ 
        goto past_the_reduce_actions;               \
    } while(0)
#define YYERROR                                     \ 
    do                                              \
    {                                               \
        yymode = YY_RAN_INTO_ERROR;                 \
        goto past_the_reduce_actions;               \
    } while (0)
#define YYVALID                                     \
    do                                              \
    {                                               \
        if (yytrial)                                \
        {                                           \
            yymode = YY_DO_ACCEPT_RULE;             \
            goto past_the_reduce_actions;           \
        }                                           \
    } while(0)
#define YYVALID_NESTED                              \
    do                                              \
    {                                               \
        if (yytrial                                 \
            && yytrial->save == 0)                  \
        {                                           \
            yymode = YY_DO_ACCEPT_RULE;             \
            goto past_the_reduce_actions;           \
        }                                           \
    } while(0)

struct YYParseState_s
{
    struct YYParseState_s *save; /* Previously saved parser state */
    int           state;
    int           errflag;
    Yshort       *ssp;         /* state stack pointer */
    YYSTYPE      *vsp;         /* value stack pointer */
    YYPOSN       *psp;         /* position stack pointer */
    YYSTYPE       val;         /* value as returned by actions */
    YYPOSN        pos;         /* position as returned by universal action */
    Yshort       *ss;          /* state stack base */
    YYSTYPE      *vs;          /* values stack base */
    YYPOSN       *ps;          /* position stack base */
    int           lexeme;      /* index of the conflict lexeme in the lexical queue */
    unsigned int  stacksize;   /* current maximum stack size */
    Yshort        ctry;        /* index in yyctable[] for this conflict */
};
typedef struct YYParseState_s YYParseState;

/* Current parser state */
static YYParseState *yyps = 0;

/* yypath != NULL: do the full parse, starting at *yypath parser state. */
static YYParseState *yypath = 0;

/* Base of the lexical value queue */
static YYSTYPE *yylvals = 0;

/* Current position at lexical value queue */
static YYSTYPE *yylvp = 0;

/* End position of lexical value queue */
static YYSTYPE *yylve = 0;

/* The last allocated position at the lexical value queue */
static YYSTYPE *yylvlim = 0;

/* Base of the lexical position queue */
static YYPOSN *yylpsns = 0;

/* Current position at lexical position queue */
static YYPOSN *yylpp = 0;

/* End position of lexical position queue */
static YYPOSN *yylpe = 0;

/* The last allocated position at the lexical position queue */
static YYPOSN *yylplim = 0;

/* Current position at lexical token queue */
static Yshort *yylexp = 0;

static Yshort *yylexemes = 0;

/* For use in generated program */
#define yytrial (yyps->save)
#define yyvsp   (yyps->vsp)
#define yyval   (yyps->val)
#define yydepth ((int)(yyps->ssp - yyps->ss))


/* Local prototypes. */
int yyparse(void);

static int yyLex1(void);

/*
 * These stack allocation functions return a non-zero value on error.
 */
static int yyExpand(void);
static int yyMoreStack(YYParseState *yyps);
/*
 * Return NULL on error.
 */
static YYParseState *yyNewState(int old_size, int growth);

static void yyFreeState(YYParseState **p);

#ifdef __cplusplus
static void yySCopy(YYSTYPE *to, YYSTYPE *from, int size);
static void yyPCopy(YYPOSN  *to, YYPOSN  *from, int size);
#else
#define yySCopy(to, from, size)         memcpy(to, from, (size) * sizeof((to)[0]))
#define yyPCopy(to, from, size)         memcpy(to, from, (size) * sizeof((to)[0]))
#endif

/*
 * Define's which could have been overridden by the user:
 *
 *
 * yydebug LOGGING OUTPUT (default to stderr)
 *
 * A yyparse() yydebug session starts with a single call to
 *   BTYACC_SET_YYDEBUG_FROM_ENV
 * followed by a single call to
 *   BTYACC_DEBUG_LOG_START
 * when yydebug has been turned ON in the BTYACC_SET_YYDEBUG_FROM_ENV call.
 *
 * When yydebug has been turned ON, the yyparse() run will then go and write
 * one or more 'log lines' a.k.a. log report events:
 *
 * Any log line consists of zero or more calls to
 *   BTYACC_DEBUG_LOG_PARTIAL
 * followed by one call to
 *   BTYACC_DEBUG_LOG_EOL
 * which is like BTYACC_DEBUG_LOG_PARTIAL but includes the line terminator (LF)
 * and concludes this yydebug log report event.
 *
 *
 * DEVELOPER NOTE
 * --------------
 *
 * When you provide your own custom implementation of these functions, this
 * combination of functions may help you to cache the logged parts up to the
 * invocation of BTYACC_DEBUG_LOG_EOL at which time you may send the entire
 * concatenated log message to the destination, e.g. a syslog server (which
 * would want to receive the entire line in a single string/message).
 */

#ifndef BTYACC_SET_YYDEBUG_FROM_ENV
#define BTYACC_SET_YYDEBUG_FROM_ENV__LOCAL_DEF
#define BTYACC_SET_YYDEBUG_FROM_ENV()   btyacc_set_yydebug_from_env()
static void btyacc_set_yydebug_from_env(void);
#endif

#ifndef BTYACC_DEBUG_LOG_START
#define BTYACC_DEBUG_LOG_START__LOCAL_DEF
#define BTYACC_DEBUG_LOG_START(msg)     btyacc_debug_log_start(msg)
static void btyacc_debug_log_start(const char *msg);
#endif

#ifndef BTYACC_DEBUG_LOG_PARTIAL
#define BTYACC_DEBUG_LOG_PARTIAL__LOCAL_DEF
#define BTYACC_DEBUG_LOG_PARTIAL        btyacc_debug_log_partial
static void btyacc_debug_log_partial(const char *msg, ...);
#endif

#ifndef BTYACC_DEBUG_LOG_EOL
#define BTYACC_DEBUG_LOG_EOL__LOCAL_DEF
#define BTYACC_DEBUG_LOG_EOL            btyacc_debug_log_eol
static void btyacc_debug_log_eol(const char *msg, ...);
#endif



#if defined(YYERROR_DETAILED)
#if !defined(yyerror_detailed)
void yyerror_detailed(const char *msg, int lexed_token, YYSTYPE yylval, YYPOSN yyposn, unsigned int yystate);
#endif
#else
#if !defined(yyerror)
void yyerror(const char *msg);
#endif
#endif




%% body




#ifndef YYERRCODE
#error Make sure you '#include' the generated btyacc .h headerfile in the .Y file itself, as it defines YYERRCODE and several other constants.
#endif

/*
 *    Parser function. Roughly looks like this:
 *
 *    int yyparse(void)
 *    {
 *    yyloop:
 *      if (reduce_possible) goto yyreduce;
 *      read_token;
 *      if (conflict)
 *      {
 *        handle_conflict;
 *        goto yyshift; or goto yyreduce;
 *      }
 *      if (shift_possible)
 *      {
 *    yyshift:
 *        do_shift;
 *        goto yyloop;
 *      }
 *      if (reduce_possible) goto yyreduce;
 *
 *      (error handling);
 *      goto yyloop;
 *
 *    yyreduce:
 *      BIG_CHUNK_OF_RULE_ACTIONS;
 *      goto yyloop;
 *
 *      (more error handling);
 *    }
 */
int yyparse(void)
{
    int yyn, yychar, yynewerrflag;
    int unsigned yystate;
    YYParseState *yyerrctx = 0;

#ifdef YYREDUCEPOSNFUNC
    int reduce_posn;
#endif

    enum {
        YY_DO_LOOP,
        YY_DO_SHIFT,
        YY_CHECK_REDUCE,
        YY_DO_REDUCE,
        YY_DO_ACCEPT_RULE,
        YY_RAN_INTO_ERROR,
        YY_HANDLE_ERROR,
        YY_AM_IN_RECOVERY,

        YY_EXIT_ABORT,
        YY_EXIT_ACCEPT
    } yymode = YY_DO_LOOP;

#if YYDEBUG
    BTYACC_SET_YYDEBUG_FROM_ENV();
    if (yydebug)
    {
        BTYACC_DEBUG_LOG_START("btyacc[<current state>,<nr of symbols on state stack>]\n");
    }
#endif

    yyps = yyNewState(0, YYDEFSTACKSIZE);
    if (!yyps) goto heap_alloc_error;
    yyps->save /* yytrial */ = 0;
    yynerrs = 0;
    yyps->errflag = 0;
    yychar = YYEMPTY;

    yyps->ssp = yyps->ss;
    yyps->vsp = yyps->vs;
    yyps->psp = yyps->ps;
    *(yyps->ssp) = yystate = 0;


    /* Main parsing loop */
yyloop:
    for(;;)
    {
    switch (yymode)
    {
    case YY_DO_LOOP:
    if ((yyn = yydefred[yystate]))
    {
        yymode = YY_DO_REDUCE;
        continue; // loop
    }

    /* Read one token */
    if (yychar < 0)
    {
        yychar = yyLex1();
        if (yychar < 0)
            yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            char const *yys = 0;

            if (yychar <= YYMAXTOKEN)
                yys = yyname[yychar];
            if (!yys)
                yys = "illegal-symbol";
            BTYACC_DEBUG_LOG_PARTIAL("btyacc[%3u,%2d%s]: read token %d (%s)",
                            yystate, yydepth, (yytrial ? ",trial" : ""), yychar, yys);
#ifdef YYDBPR
            BTYACC_DEBUG_LOG_PARTIAL(" <");
            YYDBPR(yylval);
            BTYACC_DEBUG_LOG_PARTIAL(">");
#endif
            BTYACC_DEBUG_LOG_EOL("\n");
        }
#endif
    }

    /* Do we have a conflict? */
    yyn = yycindex[yystate];
    if (yyn != 0 && (yyn += yychar) >= 0
        && yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        int ctry;

        if (yypath)
        {
            YYParseState *save;
#if YYDEBUG
            if (yydebug)
            {
                BTYACC_DEBUG_LOG_EOL("btyacc[%3u,%2d%s]: CONFLICT: following successful trial parse; LA(1) = %d (%s)\n",
                                yystate, yydepth, (yytrial ? ",trial" :""),
                                yychar, ((yychar >= 0 && yychar <= YYMAXTOKEN) ? yyname[yychar] : "???"));
            }
#endif
            /* Switch to the next conflict context */
            save = yypath;
            yypath = save->save;
            ctry = save->ctry;
            if (save->state != yystate)
            {
                yymode = YY_EXIT_ABORT;
                break; // exit loop
            }
            yyFreeState(&save);
        }
        else
        {
            /* Unresolved conflict - start/continue trial parse */
            YYParseState *save;
#if YYDEBUG
            if (yydebug)
            {
                BTYACC_DEBUG_LOG_PARTIAL("btyacc[%3u,%2d%s]: CONFLICT. LA(1) = %d (%s) : ",
                                yystate, yydepth, (yytrial ? ",trial" : ""),
                                yychar, ((yychar >= 0 && yychar <= YYMAXTOKEN) ? yyname[yychar] : "???"));
                if (yytrial)
                    BTYACC_DEBUG_LOG_EOL("ALREADY in conflict, continuing trial parse.\n");
                else
                    BTYACC_DEBUG_LOG_EOL("starting trial parse.\n");
            }
#endif
            save = yyNewState(yyps->ssp - yyps->ss + 1, YYTRIALSTACKGROWTH);
            if (!save) goto heap_alloc_error;
            save->save    = yytrial;
            save->state   = yystate;
            save->errflag = yyps->errflag;
            save->ssp     = save->ss + (yyps->ssp - yyps->ss);
            save->vsp     = save->vs + (yyps->vsp - yyps->vs);
            save->psp     = save->ps + (yyps->psp - yyps->ps);
            memcpy(save->ss, yyps->ss, (yyps->ssp - yyps->ss + 1) * sizeof(save->ss[0]));
            yySCopy(save->vs, yyps->vs, (yyps->ssp - yyps->ss + 1));
            yyPCopy(save->ps, yyps->ps, (yyps->ssp - yyps->ss + 1));
            ctry = yytable[yyn];
            if (yyctable[ctry] == -1)
            {
#if YYDEBUG
                if (yydebug && yychar >= 0)
                {
                    BTYACC_DEBUG_LOG_EOL("btyacc[%s]: backtracking 1 token: %d (%s)\n",
                                    (yytrial ? "trial" : "---"),
                                    yychar, ((yychar >= 0 && yychar <= YYMAXTOKEN) ? yyname[yychar] : "???"));
                }
#endif

                ++ctry;
            }
            save->ctry = ctry;
            if (yytrial == 0)
            {
                /* If this is a first conflict in the stack, start saving lexemes */
                if (!yylexemes)
                {
#ifdef __cplusplus
                    yylexemes = new Yshort[YYLEXDEFSTACKSIZE];
                    yylvals = new YYSTYPE[YYLEXDEFSTACKSIZE];
                    yylvlim = yylvals + YYLEXDEFSTACKSIZE;
                    yylpsns = new YYPOSN[YYLEXDEFSTACKSIZE];
                    yylplim = yylpsns + YYLEXDEFSTACKSIZE;
#else
                    yylexemes = (Yshort*)malloc(YYLEXDEFSTACKSIZE * sizeof(yylexemes[0]));
                    yylvals = (YYSTYPE*)malloc(YYLEXDEFSTACKSIZE * sizeof(yylvals[0]));
                    yylvlim = yylvals + YYLEXDEFSTACKSIZE;
                    yylpsns = (YYPOSN*)malloc(YYLEXDEFSTACKSIZE * sizeof(yylpsns[0]));
                    yylplim = yylpsns + YYLEXDEFSTACKSIZE;
#endif
                }
                if (yylvp == yylve)
                {
                    yylvp = yylve = yylvals;
                    yylpp = yylpe = yylpsns;
                    yylexp = yylexemes;
                    if (yychar >= 0)
                    {
                        *yylve++ = yylval;
                        *yylpe++ = yyposn;
                        *yylexp = yychar;
                        yychar = YYEMPTY;
                    }
                }
            }
            if (yychar >= 0)
            {
                --yylvp;
                --yylpp;
                --yylexp;
                yychar = YYEMPTY;
            }
            save->lexeme = yylvp - yylvals;
            yyps->save /* yytrial */ = save;
        }

        if (yytable[yyn] == ctry)
        {
#if YYDEBUG
            if (yydebug)
            {
                BTYACC_DEBUG_LOG_EOL("btyacc[%3u,%2d%s]: shifting to state %d, LA(1) = %d (%s)\n",
                                yystate, yydepth, (yytrial ? ",trial" : ""), yyctable[ctry],
                                yychar, ((yychar >= 0 && yychar <= YYMAXTOKEN) ? yyname[yychar] : "???"));
            }
#endif
            if (yychar < 0)
            {
                ++yylvp;
                ++yylpp;
                ++yylexp;
            }
            yychar = YYEMPTY;
            if (yyps->errflag > 0)
                --yyps->errflag;
            yystate = yyctable[ctry];
            yymode = YY_DO_SHIFT;
            continue; // loop
        }
        else
        {
            yyn = yyctable[ctry];
            yymode = YY_DO_REDUCE;
            continue; // loop
        }
    } /* End of code dealing with conflicts */


    /* Is action a shift? */
    yyn = yysindex[yystate];
    if (yyn != 0 && (yyn += yychar) >= 0
        && yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
        {
            BTYACC_DEBUG_LOG_EOL("btyacc[%3u,%2d%s]: shifting to state %d; LA(1) = %d (%s)\n",
                            yystate, yydepth, (yytrial ? ",trial" : ""), yytable[yyn],
                            yychar, ((yychar >= 0 && yychar <= YYMAXTOKEN) ? yyname[yychar] : "???"));
        }
#endif
        yychar = YYEMPTY;
        if (yyps->errflag > 0)
            --yyps->errflag;
        yystate = yytable[yyn];

        /* fall through to YY_DO_SHIFT */
        yymode = YY_DO_SHIFT;
        continue;
    }
    // else: reduce?
    yymode = YY_CHECK_REDUCE;
    continue; // loop

case YY_DO_SHIFT:
        if (yyps->ssp >= yyps->ss + yyps->stacksize - 1)
        {
            if (yyMoreStack(yyps))
                goto heap_alloc_error;
        }
        *++(yyps->ssp) = yystate;
        *++(yyps->vsp) = yylval;
        *++(yyps->psp) = yyposn;
        yymode = YY_DO_LOOP;
        continue; // loop

case YY_CHECK_REDUCE:
    yyn = yyrindex[yystate];
    if (yyn != 0 &&
        (yyn += yychar) >= 0 &&
        yyn <= YYTABLESIZE &&
        yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        yymode = YY_DO_REDUCE;
        continue; // loop
    }

    /* According to the tables, neither shift nor reduce is OK here - error! */
    if (yyps->errflag)
    {
        yymode = YY_AM_IN_RECOVERY;
        continue; // loop
    }
    yynewerrflag = 1;
    yymode = YY_HANDLE_ERROR;
    continue; // loop

case YY_RAN_INTO_ERROR:
    yynewerrflag = 0;

case YY_HANDLE_ERROR:
    if (yytrial)
    {
        int ctry;
        YYParseState *save = yytrial;
#if YYDEBUG
        if (yydebug)
        {
            BTYACC_DEBUG_LOG_EOL("btyacc[%3u,%2d%s]: ERROR, CONFLICT BACKTRACKING to state %d, %d tokens\n",
                            yystate, yydepth, (yytrial ? ",trial" : ""),
                            yytrial->state, (int)(yylvp - yylvals - yytrial->lexeme));
        }
#endif
        /* Memorize most forward-looking error state in case
             it's really an error. */
        if (yyerrctx == 0 || yyerrctx->lexeme < yylvp - yylvals)
        {
            /* Free old saved error context state */
            if (yyerrctx)
                yyFreeState(&yyerrctx);
            /* Create and fill out new saved error context state */
            yyerrctx = yyNewState(yyps->ssp - yyps->ss + 1, YYTRIALSTACKGROWTH);
            if (!yyerrctx) goto heap_alloc_error;
            yyerrctx->save = yytrial;
            yyerrctx->state = yystate;
            yyerrctx->errflag = yyps->errflag;
            yyerrctx->ssp = yyerrctx->ss + (yyps->ssp - yyps->ss);
            yyerrctx->vsp = yyerrctx->vs + (yyps->vsp - yyps->vs);
            yyerrctx->psp = yyerrctx->ps + (yyps->psp - yyps->ps);
            memcpy (yyerrctx->ss, yyps->ss,
                    (yyps->ssp - yyps->ss + 1) * sizeof(yyps->ss[0]));
            yySCopy(yyerrctx->vs, yyps->vs, (yyps->ssp - yyps->ss + 1));
            yyPCopy(yyerrctx->ps, yyps->ps, (yyps->ssp - yyps->ss + 1));
            yyerrctx->lexeme = yylvp - yylvals;
        }
        yylvp  = yylvals   + save->lexeme;
        yylpp  = yylpsns   + save->lexeme;
        yylexp = yylexemes + save->lexeme;
        yychar = YYEMPTY;
        yyps->ssp = yyps->ss + (save->ssp - save->ss);
        yyps->vsp = yyps->vs + (save->vsp - save->vs);
        yyps->psp = yyps->ps + (save->psp - save->ps);
        memcpy (yyps->ss, save->ss, (yyps->ssp - yyps->ss + 1) * sizeof(yyps->ss[0]));
        yySCopy(yyps->vs, save->vs,  yyps->vsp - yyps->vs + 1);
        yyPCopy(yyps->ps, save->ps,  yyps->psp - yyps->ps + 1);
        ctry = ++save->ctry;
        yystate = save->state;
        /* We tried shift, try reduce now */
        yyn = yyctable[ctry];
        if (yyn >= 0)
        {
            yymode = YY_DO_REDUCE;
            continue; // loop
        }
        yyps->save /* yytrial */ = save->save;
        yyFreeState(&save);

        /* Nothing left on the stack -- error */
        yynewerrflag = 1;
        if (!yytrial)
        {
#if YYDEBUG
            if (yydebug)
            {
                BTYACC_DEBUG_LOG_EOL("btyacc[%3u,%2d%s]:%s parse FAILED, entering ERROR mode\n",
                                yystate, yydepth, (yytrial ? ",trial" : ""), (yytrial ? " trial" : ""));
            }
#endif
            /* Restore state as it was in the most forward-advanced error */
            yylvp  = yylvals   + yyerrctx->lexeme;
            yylpp  = yylpsns   + yyerrctx->lexeme;
            yylexp = yylexemes + yyerrctx->lexeme;
            yychar = yylexp[-1];
            yylval = yylvp[-1];
            yyposn = yylpp[-1];
            yyps->ssp = yyps->ss + (yyerrctx->ssp - yyerrctx->ss);
            yyps->vsp = yyps->vs + (yyerrctx->vsp - yyerrctx->vs);
            yyps->psp = yyps->ps + (yyerrctx->psp - yyerrctx->ps);
            memcpy (yyps->ss, yyerrctx->ss,
                    (yyps->ssp - yyps->ss + 1) * sizeof(yyps->ss[0]));
            yySCopy(yyps->vs, yyerrctx->vs,  yyps->vsp - yyps->vs + 1);
            yyPCopy(yyps->ps, yyerrctx->ps,  yyps->psp - yyps->ps + 1);
            yystate = yyerrctx->state;
            yyFreeState(&yyerrctx);
        }
        else
        {
            // loop through the trial stack by using the outer loop for this:
            yymode = YY_HANDLE_ERROR;
            continue; // loop
        }
    }
    if (yynewerrflag)
    {
#ifdef YYERROR_DETAILED
        yyerror_detailed("parse error", yychar, yylval, yyposn, yystate);
#else
        yyerror("parse error");
#endif
    }
    ++yynerrs;

case YY_AM_IN_RECOVERY:
    if (yyps->errflag < 3)
    {
        yyps->errflag = 3;
        yymode = YY_AM_IN_RECOVERY; // used to detect whether we need to loop below
        for (;;)
        {
            yyn = yysindex[*(yyps->ssp)];
            if (yyn != 0
                && (yyn += YYERRCODE) >= 0
                && yyn <= YYTABLESIZE
                && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                {
                    BTYACC_DEBUG_LOG_EOL("btyacc[%3d,%2d%s]: ERROR recovery shifts to state %d\n",
                                    *(yyps->ssp), yydepth, (yytrial ? ",trial" : ""),
                                    yytable[yyn]);
                }
#endif
                yystate = yytable[yyn];
                yymode = YY_DO_SHIFT;
                break; // break out of inner loop to continue looping in the outer one...
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                {
                    BTYACC_DEBUG_LOG_EOL("btyacc[%3d,%2d%s]: ERROR recovery discards this state\n",
                                    *(yyps->ssp), yydepth, (yytrial ? ",trial" : ""));
                }
#endif
                if (yyps->ssp <= yyps->ss)
                {
                    yymode = YY_EXIT_ABORT;
                    break; // break out of inner loop to continue looping in the outer one...
                }
                if (!yytrial)
                {
                    YYDELETEVAL(yyps->vsp[0], 1);
                    YYDELETEPOSN(yyps->psp[0], 1);
                }
                --(yyps->ssp);
                --(yyps->vsp);
                --(yyps->psp);
            }
        }
        if (yymode != YY_AM_IN_RECOVERY)
            continue; // loop
    }
    else
    {
        if (yychar == 0)
        {
            yymode = YY_EXIT_ABORT;
            continue;
        }
#if YYDEBUG
        if (yydebug)
        {
            char const *yys = 0;

            if (yychar <= YYMAXTOKEN)
                yys = yyname[yychar];
            if (!yys)
                yys = "illegal-symbol";
            BTYACC_DEBUG_LOG_EOL("btyacc[%3u,%2d%s]: ERROR recovery discards token %d (%s)\n",
                            yystate, yydepth, (yytrial ? ",trial" : ""), yychar, yys);
        }
#endif
        if (!yytrial)
        {
            YYDELETEVAL(yylval, 0);
            YYDELETEPOSN(yyposn, 0);
        }
        yychar = YYEMPTY;
        yymode = YY_DO_LOOP;
        continue;
    }

    /* Reduce the rule */
case YY_DO_REDUCE:
    {
    int yyruletokencount = yylen[yyn];
#if YYDEBUG
    if (yydebug)
    {
        BTYACC_DEBUG_LOG_PARTIAL("btyacc[%3u,%2d%s]: reducing by rule %d (%s); LA(1) = %d (%s)",
                        yystate, yydepth, (yytrial ? ",trial" : ""), yyn, yyrule[yyn],
                        yychar, ((yychar >= 0 && yychar <= YYMAXTOKEN) ? yyname[yychar] : "???"));
#ifdef YYDBPR
        if (yyruletokencount > 0)
        {
            int i;
            BTYACC_DEBUG_LOG_PARTIAL(" <");
            for (i = yyruletokencount; i > 0; --i)
            {
                if (i != yyruletokencount)
                    BTYACC_DEBUG_LOG_PARTIAL(", ");
                YYDBPR(yyps->vsp[1 - i]);
            }
            BTYACC_DEBUG_LOG_PARTIAL(">");
        }
#endif
        BTYACC_DEBUG_LOG_EOL("\n");
    }
#endif
    if (yyps->ssp + 1 - yyruletokencount >= yyps->ss + yyps->stacksize)
    {
        if (yyMoreStack(yyps))
            goto heap_alloc_error;
    }

#ifdef _YACC_DEFAULT_ACTION_
    /* "$$ = NULL" default action */
#ifdef __cplusplus
    // C++: YYSTYPE can be an arbitrary class, so we need to explicitly zero it:
    YYSTYPE_ZERO(yyps->val);
#else
    memset(&yyps->val, 0, sizeof(yyps->val));
#endif
#else
    /* RA: bison compatibility: default action is '$$ = $1;' */
    if (yyruletokencount > 0)
    {
        yyps->val = yyps->vsp[1 - yyruletokencount];
    }
#endif

    /*
     * Default reduced position is NULL -- no position at all. No
     * position will be assigned at trial time and if no position
     * handling is present
     */
#ifdef __cplusplus
    /* C++: YYPOSN can be an arbitrary class, so we need to explicitly zero it: */
    YYPOSN_ZERO(yyps->pos);
#else
    memset(&yyps->pos, 0, sizeof(yyps->pos));
#endif

#ifdef YYREDUCEPOSNFUNC
    reduce_posn = 1;
#endif

    // set this up as the default destination and since we want to know if the user code
    // did set a different target via YYACCEPT and friends:
    yymode = YY_DO_LOOP;

    switch (yyn)
    {

%% trailer

    default:
        break;
    }

past_the_reduce_actions:
    if (yymode != YY_DO_LOOP)
        continue; // loop

#if YYDEBUG
#if defined(YYDBPR)
    if (yydebug)
    {
        BTYACC_DEBUG_LOG_PARTIAL("btyacc[%3u,%2d%s]: after reduction, result is ",
                        yystate, yydepth, (yytrial ? ",trial" : ""));
        YYDBPR(yyps->val);
        BTYACC_DEBUG_LOG_EOL("\n");
    }
#endif
#endif

    /* Perform user-defined position reduction */
#ifdef YYREDUCEPOSNFUNC
    if (!yytrial)
    {
        YYCALLREDUCEPOSN(YYREDUCEPOSNFUNCARG);
    }
#endif

    yyps->ssp -= yyruletokencount;
    yystate = *(yyps->ssp);
    yyps->vsp -= yyruletokencount;
    yyps->psp -= yyruletokencount;
    }

    {
    int yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
        {
            BTYACC_DEBUG_LOG_EOL("btyacc[  0,%2d%s]: reduced, shifting to final state %d\n",
                            yydepth, (yytrial ? ",trial" : ""), YYFINAL);
        }
#endif
        yystate = YYFINAL;
        *++(yyps->ssp) = YYFINAL;
        *++(yyps->vsp) = yyps->val;
        yyretlval = yyps->val;  /* return value of root non-terminal to yyretlval */
        *++(yyps->psp) = yyps->pos;
        yyretposn = yyps->pos;  /* return value of root position to yyretposn */
        if (yychar < 0)
        {
            yychar = yyLex1();
            if (yychar < 0)
            {
                yychar = 0;
            }
#if YYDEBUG
            if (yydebug)
            {
                char const *yys = 0;

                if (yychar <= YYMAXTOKEN)
                    yys = yyname[yychar];
                if (!yys)
                    yys = "illegal-symbol";
                BTYACC_DEBUG_LOG_EOL("btyacc[%3d,%2d%s]: read %d (%s)\n",
                                YYFINAL, yydepth, (yytrial ? ",trial" : ""), yychar, yys);
            }
#endif
        }
        if (yychar == 0)
        {
            if (yytrial)
                yymode = YY_DO_ACCEPT_RULE;
            else
                yymode = YY_EXIT_ACCEPT;
        }
        else
        {
            assert(yymode == YY_DO_LOOP);   // has already been set further above...
        }
        continue; // loop
    }

    yyn = yygindex[yym];
    if (yyn != 0 && (yyn += yystate) >= 0 &&
        yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
    {
        yystate = yytable[yyn];
    }
    else
    {
        yystate = yydgoto[yym];
    }
#if YYDEBUG
    if (yydebug)
    {
        BTYACC_DEBUG_LOG_EOL("btyacc[%3d,%2d%s]: reduced, shifting to state %d; LA(1) = %d (%s)\n",
                        *(yyps->ssp), yydepth, (yytrial ? ",trial" : ""), yystate,
                        yychar, ((yychar >= 0 && yychar <= YYMAXTOKEN) ? yyname[yychar] : "???"));
    }
#endif
    if (yyps->ssp >= yyps->ss + yyps->stacksize - 1)
    {
        if (yyMoreStack(yyps))
            goto heap_alloc_error;
    }
    *++(yyps->ssp) = yystate;
    *++(yyps->vsp) = yyps->val;
    *++(yyps->psp) = yyps->pos;
    }
    yymode = YY_DO_LOOP;
    continue;


    /*
     * Reduction declares that this path is valid.
     * Set yypath and do a full parse.
     */
case YY_DO_ACCEPT_RULE:
    if (yypath)
    {
        yymode = YY_EXIT_ABORT;
        continue; // loop;
    }
    while (yytrial)
    {
        YYParseState *save = yytrial;
        yyps->save /* yytrial */ = save->save;
        save->save = yypath;
        yypath = save;
    }
#if YYDEBUG
    if (yydebug)
    {
        BTYACC_DEBUG_LOG_EOL("btyacc[%3d,%2d%s]: CONFLICT trial successful, "
                        "backtracking to state %d, %d tokens\n",
                        yystate, yydepth, (yytrial ? ",trial" : ""),
                        yypath->state, (int)(yylvp - yylvals - yypath->lexeme));
    }
#endif
    if (yyerrctx)
    {
        yyFreeState(&yyerrctx);
    }
    yychar = YYEMPTY;
    yyps->ssp = yyps->ss + (yypath->ssp - yypath->ss);
    yyps->vsp = yyps->vs + (yypath->vsp - yypath->vs);
    yyps->psp = yyps->ps + (yypath->psp - yypath->ps);
    memcpy (yyps->ss, yypath->ss, (yyps->ssp - yyps->ss + 1) * sizeof(yyps->ss[0]));
    yySCopy(yyps->vs, yypath->vs,  yyps->vsp - yyps->vs + 1);
    yyPCopy(yyps->ps, yypath->ps,  yyps->psp - yyps->ps + 1);
    yylvp = yylvals + yypath->lexeme;
    yylpp = yylpsns + yypath->lexeme;
    yylexp = yylexemes + yypath->lexeme;
    yystate = yypath->state;
    yymode = YY_DO_LOOP;
    continue;


heap_alloc_error:
#if YYDEBUG
    if (yydebug)
    {
        BTYACC_DEBUG_LOG_EOL("btyacc[%3d,--%s]: out of memory\n",
                        yystate, (yytrial ? ",trial" : ""));
    }
#endif
case YY_EXIT_ABORT:
    {
        YYSTYPE *pv;
        YYPOSN *pp;

        if (yyerrctx)
        {
            yyFreeState(&yyerrctx);
        }

        for (pv = yyps->vs; pv < yyps->vsp; ++pv)
        {
            YYDELETEVAL(*pv, 2);
        }

        for (pp = yyps->ps; pp < yyps->psp; ++pp)
        {
            YYDELETEPOSN(*pp, 2);
        }

        while (yyps)
        {
            YYParseState *save = yyps;
            yyps = save->save;
            yyFreeState(&save);
        }
        while (yypath)
        {
            YYParseState *save = yypath;
            yypath = save->save;
            yyFreeState(&save);
        }
        return 1;
    }

case YY_EXIT_ACCEPT:
    //if (yytrial)         -- these two lines have moved into the code spots where the 'goto yyaccept' was before.
    //  goto yyvalid;
    if (yyerrctx)
    {
        yyFreeState(&yyerrctx);
    }
    while (yyps)
    {
        YYParseState *save = yyps;
        yyps = save->save;
        yyFreeState(&save);
    }
    while (yypath)
    {
        YYParseState *save = yypath;
        yypath = save->save;
        yyFreeState(&save);
    }
    return 0;
    }
    }
}


/* Call yylex() unless the token has already been read. */
static int yyLex1(void)
{
    if (yylvp < yylve)
    {
        /* we're currently re-reading tokens */
        yylval = *yylvp++;
        yyposn = *yylpp++;
        return *yylexp++;
    }
    else if (yytrial)
    {
        /* in trial mode; save scanner results for future parse attempts */
        if (yylvp == yylvlim)
        {
            if (yyExpand())
                return -2;
        }
        *yylexp = yylex();
        *yylvp++ = yylval;
        ++yylve;
        *yylpp++ = yyposn;
        ++yylpe;
        return *yylexp++;
    }
    else
    {
        /* normal operation, no conflict encountered */
        return yylex();
    }
}

/* Enlarge lexical value queue */
static int yyExpand(void)
{
    int p = yylvp - yylvals;
    int s = yylvlim - yylvals;
    s += YYSTACKGROWTH;
    {
        Yshort  *tl = yylexemes;
        YYSTYPE *tv = yylvals;
        YYPOSN  *tp = yylpsns;
#ifdef __cplusplus
        yylvals = new YYSTYPE[s];
        yylpsns = new YYPOSN[s];
        yylexemes = new Yshort[s];
#else
        yylvals = (YYSTYPE*)malloc(s * sizeof(yylvals[0]));
        yylpsns = (YYPOSN*)malloc(s * sizeof(yylpsns[0]));
        yylexemes = (Yshort*)malloc(s * sizeof(yylexemes[0]));
        if (!yylvals || !yylpsns || !yylexemes)
        {
            free(yylvals);
            free(yylpsns);
            free(yylexemes);
            yylvals = tv;
            yylpsns = tp;
            yylexemes = tl;
            return -1;
        }
#endif
        memcpy(yylexemes, tl, (s - YYSTACKGROWTH) * sizeof(yylexemes[0]));
        yySCopy(yylvals, tv, s - YYSTACKGROWTH);
        yyPCopy(yylpsns, tp, s - YYSTACKGROWTH);
#ifdef __cplusplus
        delete[] tl;
        delete[] tv;
        delete[] tp;
#else
        free(tl);
        free(tv);
        free(tp);
#endif
    }
    yylvp = yylve = yylvals + p;
    yylvlim = yylvals + s;
    yylpp = yylpe = yylpsns + p;
    yylplim = yylpsns + s;
    yylexp = yylexemes + p;
    return 0;
}

#ifdef __cplusplus

static void yySCopy(YYSTYPE *to, YYSTYPE *from, int size)
{
    int i;
    for (i = size - 1; i >= 0; --i)
    {
        to[i] = from[i];
    }
}

static void yyPCopy(YYPOSN *to, YYPOSN *from, int size)
{
    int i;
    for (i = size - 1; i >= 0; --i)
    {
        to[i] = from[i];
    }
}

#endif

static int yyMoreStack(YYParseState *yyps)
{
    int p = yyps->ssp - yyps->ss;
    Yshort  *tss = yyps->ss;
    YYSTYPE *tvs = yyps->vs;
    YYPOSN  *tps = yyps->ps;
#ifdef __cplusplus
    yyps->ss = new Yshort [yyps->stacksize + YYSTACKGROWTH];
    yyps->vs = new YYSTYPE[yyps->stacksize + YYSTACKGROWTH];
    yyps->ps = new YYPOSN [yyps->stacksize + YYSTACKGROWTH];
#else
    yyps->ss = (Yshort*)malloc(sizeof(yyps->ss[0]) * (yyps->stacksize + YYSTACKGROWTH));
    yyps->vs = (YYSTYPE*)malloc(sizeof(yyps->vs[0]) * (yyps->stacksize + YYSTACKGROWTH));
    yyps->ps = (YYPOSN*)malloc(sizeof(yyps->ps[0]) * (yyps->stacksize + YYSTACKGROWTH));
    if (!yyps->ss || !yyps->vs || !yyps->ps)
    {
        free(yyps->ss);
        free(yyps->vs);
        free(yyps->ps);
        yyps->ss = tss;
        yyps->vs = tvs;
        yyps->ps = tps;
        return -1;
    }
#endif
    memcpy(yyps->ss, tss, yyps->stacksize * sizeof(yyps->ss[0]));
    yySCopy(yyps->vs, tvs, yyps->stacksize);
    yyPCopy(yyps->ps, tps, yyps->stacksize);
    yyps->stacksize += YYSTACKGROWTH;
#ifdef __cplusplus
    delete[] tss;
    delete[] tvs;
    delete[] tps;
#else
    free(tss);
    free(tvs);
    free(tps);
#endif
    tss = 0;
    tvs = 0;
    tps = 0;
    yyps->ssp = yyps->ss + p;
    yyps->vsp = yyps->vs + p;
    yyps->psp = yyps->ps + p;
#if YYDEBUG
    if (yydebug)
    {
        BTYACC_DEBUG_LOG_EOL("btyacc: stack size increased to %d\n", yyps->stacksize);
    }
#endif
    return 0;
}


static YYParseState *yyNewState(int old_size, int growth)
{
    YYParseState *p;
    int size = old_size + growth;

#ifdef __cplusplus
    p = new YYParseState;
    p->ss = new Yshort [size];
    p->vs = new YYSTYPE[size];
    p->ps = new YYPOSN [size];

    /*
     * C++: YYSTYPE and YYPOSN can be arbitrary classes, so we need to
     *      explicitly zero them
     *
     * However, keep in mind that the caller of this function will fill the items
     * up to index [old_size] (not including that one)!
     */
    for (int i = old_size; i < size; i++)
    {
        YYSTYPE_ZERO(p->vs[i]);
        YYPOSN_ZERO(p->ps[i]);
    }
#else
    p = (YYParseState*)malloc(sizeof(p[0]));
    if (!p) return NULL;
    p->ss = (Yshort*) malloc(size * sizeof(p->ss[0]));
    p->vs = (YYSTYPE*)malloc(size * sizeof(p->vs[0]));
    p->ps = (YYPOSN*) malloc(size * sizeof(p->ps[0]));
    if (!p->ss || !p->vs || !p->ps)
    {
        free(p->ss);
        free(p->vs);
        free(p->ps);
        free(p);
        return NULL;
    }
    /*
     * Keep in mind that the caller of this function will fill the items
     * up to index [old_size] (not including that one)!
     */
    memset(&p->vs[old_size], 0, (size - old_size) * sizeof(p->vs[0]));
    memset(&p->ps[old_size], 0, (size - old_size) * sizeof(p->ps[0]));
#endif
    p->stacksize = size;
    return p;
}

static void yyFreeState(YYParseState **v)
{
    YYParseState *p = *v;

#ifdef __cplusplus
    if (p)
    {
        delete[] p->ss;
        delete[] p->vs;
        delete[] p->ps;
        delete p;
    }
#else
    if (p)
    {
        free(p->ss);
        free(p->vs);
        free(p->ps);
        free(p);
    }
#endif

    *v = 0;
}

/*
 * ----------------------------------------------------------------------
 * Several functions which can be overridden by the user when she has set
 * up the proper #define's.
 *
 * Note:
 *
 * We assume that the compiler is smart enough to discard these local
 * functions when their references through the #define's have been
 * overridden.
 * ----------------------------------------------------------------------
 */

#ifdef BTYACC_SET_YYDEBUG_FROM_ENV__LOCAL_DEF
static void btyacc_set_yydebug_from_env(void)
{
    const char *yys = getenv("YYDEBUG");
    char yyn;

    if (yys)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
}
#endif

#ifdef BTYACC_DEBUG_LOG_START__LOCAL_DEF
static void btyacc_debug_log_start(const char *msg)
{
    fprintf(stderr, "%s", msg);
}
#endif

#ifdef BTYACC_DEBUG_LOG_PARTIAL__LOCAL_DEF
static void btyacc_debug_log_partial(const char *msg, ...)
{
    va_list args;

    va_start(args, msg);
    vfprintf(stderr, msg, args);
    va_end(args);
}
#endif

#ifdef BTYACC_DEBUG_LOG_EOL__LOCAL_DEF
static void btyacc_debug_log_eol(const char *msg, ...)
{
    va_list args;

    va_start(args, msg);
    vfprintf(stderr, msg, args);
    va_end(args);
}
#endif

%% line_position
#line %d "%s"

%% comment_start
/*
%% comment_next_line
**
%% comment_end
*/

%% action_case_start
    case %d:

%% action_code
        %s;


%% action_case_end
        break;


%% action_if_!yytrial_start
        if (!yytrial)
        {

%% action_if_!yytrial_end

        } /* end: if (!yytrial) */

%% action_block_start
{
%% action_block_end
}
%% yyval.tag_reference
yyval.%s
%% yyval_reference
yyval
%% yyvsp.tag_reference
yyvsp[%d].%s
%% yyvsp_reference
yyvsp[%d]
%% rflag_prefix
static
%% !rflag_prefix

%% int_table_start
%sYshort %29s[%5d] = {%5d%s
%% int_table_entry
%5d%s
%% int_table_entry_separator
,
%% int_table_end

};

%% table_size


#define YYTABLESIZE %d



%% defines_file_protection_start

#ifndef _BTYACC_DEFINES_H_
#define _BTYACC_DEFINES_H_



%% defines_file_protection_end


#endif /* _BTYACC_DEFINES_H_ */


%% token_charset
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$
%% literal_token_name_template
YYSYMBOL_%%s
%% --- was: BTYACC_SYMBOL_%s_%%s (%s ~ yacc filename prefix)
%% --- WARNING: the '%%s' MUST be in there or the literal token expansion won't make it into the symbol name proper!

%% define_token
#define %-60s %5d

%% yystype_extern_decl

extern YYSTYPE yylval;

%% define_default_yystype

#ifndef YYSTYPE
typedef int YYSTYPE;
#define YYSTYPE YYSTYPE
#endif

#ifdef __cplusplus
#ifndef YYSTYPE_ZERO
/* this macro is used to ZERO one YYSTYPE instance: */
#define YYSTYPE_ZERO(yylval)        yylval = 0
#endif
#endif

#ifndef YYDBPR
/* display the content of one YYSTYPE instance in the parser debug output: */
#define YYDBPR(yystype)    BTYACC_DEBUG_LOG_PARTIAL("%d", (int)(yystype))
#endif


%% union_decl_start

typedef union
%% union_decl_end
 yystype_t;
#define YYSTYPE yystype_t


%% define_yymaxtoken

#define YYMAXTOKEN %5d


%% define_yyfinal

#define YYFINAL %5d


%% define_yydebug

#ifndef YYDEBUG
#define YYDEBUG %d
#endif


%% debug_yy_null
0
%% debug_yyname_strings_start

#if YYDEBUG
%schar const *yyname[] = {

%% debug_yyname_strings_separator
,
%% debug_yyname_strings_end
};
#endif


%% debug_yyrule_strings_start

#if YYDEBUG
%schar const *yyrule[] = {

%% debug_yyrule_strings_separator
,
%% debug_yyrule_strings_end
};
#endif


%% DEFINES_FILENAME
%s%s.tab.h
%% OUTPUT_FILENAME
%s%s.tab.c
%% CODE_FILENAME
%s%s.code.c
%% VERBOSE_FILENAME
%s%s.output
%% ---
