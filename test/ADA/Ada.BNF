/*
	Brad Clark
	CSci 571 HW #2
	10/7/93

	YACCable grammar for Ada
*/
/*--------------------------------------------------------------------------*/
/*									    */
/*			 A LALR(1) grammar for ANSI Ada*		    */
/*									    */
/*			 Adapted for YACC (UNIX) Inputs			    */
/*									    */
/*                                                                          */
/*                             Herman Fischer                               */
/*                           Litton Data Systems                            */
/*                       8000 Woodley Ave., ms 44-30                        */
/*                              Van Nuys, CA                                */
/*                                                                          */
/*                              818/902-5139                                */
/*                           HFischer@eclb.arpa                             */
/*                        {cepu,trwrb}!litvax!fischer                       */
/*                                                                          */
/*                             March 26, 1984                               */
/*									    */
/*                   A Contribution to the Public Domain                    */
/*                                   for                                    */
/*            Research, Development, and Training Purposes Only             */
/*                                                                          */
/*       Any Corrections or Problems are to be Reported to the Author       */
/*                                                                          */
/*                                                                          */
%{
static
char rcsid[] =
"$Header: ./RCS/ada.y,v 1.6 89/10/12 17:22:08 shields Exp $";
%}
/* $Log:	ada.y,v $
 * Revision 1.6  89/10/12  17:22:08  shields
 * minor changes to formatting
 * 
 * Revision 1.5  89/10/11  21:51:13  shields
 * minor change to 'yyerror'
 * 
 * Revision 1.4  89/10/11  21:37:29  shields
 * changed "extern" definition of 'yytext' to depend on whether the
 *    lexer is generated by LEX or FLEX - LEX defines 'yytext' as type
 *    'char []', while FLEX defines 'yytext' as type 'char *', and these
 *    types are not compatible for "extern" objects
 * minor change to 'yyerror'
 * 
 * Revision 1.3  88/06/11  19:28:56  shields
 * simplified/clarified/restructured grammar for readability and to make
 *    semantic actions easier to construct
 * reduced the Ada superset defined by the grammar in various ways:
 *    'object_d' no longer generates deferred constant declaractions
 *    'aggr' no longer generates index and discriminant constraints, and
 *       is no longer used to generate parenthesized expressions or
 *       parenthesized expression lists, except where used as an aggregate
 *    'name' no longer used to generate procedure and entry call statements
 * deleted unused operator syntactic categories
 * 
 * Revision 1.2  88/06/09  23:42:41  shields
 * simplified binary operator part of grammar using YACC %left, %nonassoc,
 *    and %prec disambiguation facilities - also simplified some of the
 *    rules for readability
 * corrected error in rules for 'rec_rep_cl' - '.algt_cl.' could generate
 *    a sequence ending in '..prag..', and '..cmpon_cl..' could be empty,
 *    resulting in a record representation clause containing only a
 *    sequence of pragmas in place of the sequence of component clauses,
 *    in violation of LRM 2.8(5)
 * restructured rules involving pragmas for readability and to make semantic
 *    actions easier to define
 * (NOTE: pragma rule correction and restructuring introduced shift/reduce
 *    ambiguities resolvable by YACC's choice of the shift action, so the
 *    ambiguities were left as-is)
 * deleted rules defining reserved words 'DIGITS', 'DELTA' and 'RANGE' as
 *    alternatives for 'attribute_designator' - corresponds to change made
 *    in LEX definition of lexer to return all attribute designators
 *    as 'IDENTIFIER' tokens
 * 
 * Revision 1.1  88/05/09  17:29:55  shields
 * added missing '.fml_part.' at end of first alternative rule for 'subprg_spec'
 * added error rule
 *    later_decl_item : error ';'
 * cleaned up grammar presentation format slightly
 * added RCS Header and Log keywords to source file
 * 
 * Revision 1.0  87/12/17  18:22:11  jwabik
 * original version copied from SIMTEL20
 *
 */
/*                                                                          */
/*                                                                          */
/*  Mods to the original: Jeff Wabik, Control Data Corporation		    */
/*  December, 1987:  Mainly reformatted to make the YACC readable           */
/*  { umn-cs!shamash!jwabik }						    */
/*  Disclaim:  CDC is not responsible.					    */
/*                                                                          */
/*  Note that Herm Fischer's new address, effective 9/23/87, is:            */
/*  { hermix!fischer@rand-unix.ARPA }					    */
/*  { {ihnp4,decvax,trwrb,seismo,etc.}!hermix!fischer }			    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*                              adapted from                                */
/*                              the grammar                                 */
/*                                  by:                                     */
/*									    */
/*            Gerry Fisher                         Philippe Charles         */
/*                                                                          */
/*    Computer Sciences Corporation     &             Ada  Project          */
/*         4045 Hancock Street                     New York University      */
/*         San Diego, CA 92121                      251 Mercer Street       */
/*                                               New York, New York 10012   */
/*									    */
/*									    */
/*    This grammar is organized in the same order as the syntax summary     */
/* in appendix E of the ANSI Ada Reference Manual.   All reserved words     */
/* are written in upper case letters.  The lexical categories               */
/* NUMERIC_LITERAL, STRING_LITERAL, etc, are viewed as terminals.  The      */
/* rules for pragmas as stated in chapter 2, section 8, have been           */
/* incorporated in the grammar.  Comments are included wherever we had to   */
/* deviate from the syntax given in appendix E.  Different symbols used	    */
/* here (to comply with YACC requirements) are of note:                     */
/*	{,something}	is denoted ...something..			    */
/*	{something}	is denoted ..something..			    */
/*	[something]	is denoted .something.				    */
/* Constructs involving meta brackets, e.g., ...IDENTIFIER.. are            */
/* represented by a nonterminal formed by concatenating the construct       */
/* symbols (as ...IDENTIFIER.. in the example) for which the rules are      */
/* given at the end.  When reading this grammar, it is important to note    */
/* that all symbols appearing in the rules are separated by one or more     */
/* blanks.  A string such as 'IDENTIFIER_type_mark' is actually a single    */
/* nonterminal symbol defined at the end of the rules.  The '/*' symbol is  */
/* used to indicate that the rest of the line is a comment, just as in      */
/* YACC programs.                                                           */
/*                                                                          */
/*     This grammar is presented here in a form suitable for input to a     */
/* YACC parser generator.  It has  been  processed  by the Bell System      */
/* III LEX/YACC combination, and tested against over 400 ACVC tests.        */
/*									    */
/* *Ada is a registered trade mark of the  Department of  Defense  (Ada     */
/* Joint Program  Office).						    */
/*									    */
/*--------------------------------------------------------------------------*/

%{

#include <stdio.h>
#include <ctype.h>

#ifdef lex
extern char yytext[];
#endif lex
#ifdef flex
extern char *yytext;
#endif flex
extern int yylineno;

%}


%union {
	char *y_str;
	int y_num;
};


/*%terminals -----------------------------------------------------------    */

%token ABORT_ ABS_ ACCEPT_ ACCESS_ ALL_ AND_ ARRAY_
%token AT_ BEGIN_ BODY_ CASE_ CONSTANT_
%token DECLARE_ DELAY_ DELTA_ DIGITS_ DO_ ELSE_ ELSIF_
%token END_ ENTRY_ EXCEPTION_ EXIT_ FOR_
%token FUNCTION_ GENERIC_ GOTO_ IF_ IN_ IS_ LIMITED_
%token LOOP_ MOD_ NEW_ NOT_ NULL_ OF_ OR_
%token OTHERS_ OUT_ PACKAGE_ PRAGMA_ PRIVATE_
%token PROCEDURE_ RAISE_ RANGE_ RECORD_ REM_
%token RENAMES_ RETURN_ REVERSE_ SELECT_ SEPARATE_
%token SUBTYPE_ TASK_ TERMINATE_ THEN_
%token TYPE_ USE_ WHEN_ WHILE_ WITH_ XOR_

%token IDENTIFIER NUMERIC_LITERAL STRING_LITERAL CHARACTER_LITERAL
%token ARROW_ DBLDOT_ EXP_ ASSIGN_ NOTEQL_ GTEQL_ LTEQ_ L_LBL_ R_LBL_ BOX_

%left		','
%left		AND_ OR_ XOR_
%nonassoc	'=' NOTEQL_ '<' LTEQ_ '>' GTEQL_ NOT_ IN_
%left		'+' '-' '&'
%left		'*' '/' MOD_ REM_
%nonassoc	EXP_

%start	compilation

/* The following 3 shift/reduce errors, resolved by YACC by choosing
   the shift action, are expected */
/* shift PRAGMA_ in '..prag..' iteration, or
   reduce <empty> -> '.algt_cl.' terminating '..prag..' iteration and starting
   '..cmpon_cl..' iteration within 'rec_rep_cl' */
/* shift PRAGMA_ in '..ent_d..' iteration, or
   reduce <empty> -> '..rep_cl..' terminating '..ent_d..' iteration and starting
   '..rep_cl..' iteration within '.task_interface.' */
/* shift PRAGMA_ in 'cmpon_ds' iteration, or
   reduce 'cmpon_ds' -> 'cmpons' terminating 'cmpon_ds' iteration and starting
   'cmpons' iteration within 'cmpons' */

%%	/* beginning of rules section */


/* 2.8 */

prag		: PRAGMA_ IDENTIFIER .prag_arg_part. ';'
		;

prag_arg_part	: '(' arg_ascs ')'

arg_ascs	: arg_asc
		| arg_ascs ',' arg_asc
		;

arg_asc		: expr
		| IDENTIFIER ARROW_ expr
		;


/* 3.1 */

basic_d		: object_d
		| number_d
		| ty_d
		| subty_d
		| subprg_d
		| pkg_d
		| task_d
		| gen_d
		| excptn_d
		| gen_inst
		| renaming_d
		| defer_const_d
		| error ';'
		;


/* 3.2 */

object_d	: idents ':' subty_ind .ASSIGN_expr. ';'
		| idents ':' CONSTANT_ subty_ind ASSIGN_ expr ';'
		| idents ':' c_arr_def .ASSIGN_expr. ';'
		| idents ':' CONSTANT_ c_arr_def ASSIGN_ expr ';'
		;

number_d	: idents ':' CONSTANT_ ASSIGN_ expr ';'
		;

idents		: IDENTIFIER
		| idents ',' IDENTIFIER
		;


/* 3.3.1 */

ty_d		: full_ty_d
		| incomplete_ty_d
		| priv_ty_d
		;

full_ty_d	: TYPE_ IDENTIFIER .discr_part. IS_ ty_def ';'
		;

ty_def		: enum_ty_def
		| integer_ty_def
		| real_ty_def
		| array_ty_def
		| rec_ty_def
		| access_ty_def
		| derived_ty_def
		;


/* 3.3.2 */

subty_d		: SUBTYPE_ IDENTIFIER IS_ subty_ind ';'
		;

subty_ind	: ty_mk .constrt.
		;

ty_mk		: expanded_n
		;

constrt		: rng_c
		| fltg_point_c
		| fixed_point_c
/*		| idx_c /* as 'idx_or_discr_c' */
/*		| discr_c /* as 'idx_or_discr_c' */
		| idx_or_discr_c
		;


/* 3.4 */

derived_ty_def	: NEW_ subty_ind
		;


/* 3.5 */

rng_c		: RANGE_ rng
		;

rng		: name /* must be an 'attribute' */
		| sim_expr DBLDOT_ sim_expr
		;


/* 3.5.1 */

enum_ty_def	: '(' enum_lit_specs ')'
		;

enum_lit_specs	: enum_lit_spec
		| enum_lit_specs ',' enum_lit_spec
		;

enum_lit_spec	: enum_lit
		;

enum_lit	: IDENTIFIER
		| CHARACTER_LITERAL
		;


/* 3.5.4 */

integer_ty_def	: rng_c
		;


/* 3.5.6 */

real_ty_def	: fltg_point_c
		| fixed_point_c
		;


/* 3.5.7 */

fltg_point_c	: fltg_accuracy_def .rng_c.
		;

fltg_accuracy_def	: DIGITS_ sim_expr
		;


/* 3.5.9 */

fixed_point_c	: fixed_accuracy_def .rng_c.
		;

fixed_accuracy_def	: DELTA_ sim_expr
		;


/* 3.6 */

array_ty_def	: uncnstrnd_array_def
		| c_arr_def
		;

uncnstrnd_array_def	: ARRAY_ '(' idx_subty_defs ')' OF_ subty_ind
		;

idx_subty_defs	: idx_subty_def
		| idx_subty_defs ',' idx_subty_def
		;

idx_subty_def	: name RANGE_ BOX_
		;

c_arr_def	: ARRAY_ idx_c OF_ subty_ind
		;

idx_c		: '(' dscr_rngs ')'
		;

dscr_rngs	: dscr_rng
		| dscr_rngs ',' dscr_rng
		;

dscr_rng	: rng
		| name rng_c
		;


/* 3.7 */

rec_ty_def	: RECORD_ cmpons END_ RECORD_
		;

cmpons		: ..prag.. cmpon_ds
		| ..prag.. .cmpon_ds. variant_part
		| ..prag.. NULL_ ';'
		| cmpons prag
		;

cmpon_ds	: cmpon_d
		| cmpon_ds cmpon_d
		| cmpon_ds prag
		;

cmpon_d		: idents ':' cmpon_subty_def .ASSIGN_expr. ';'
		;

cmpon_subty_def	: subty_ind
		;


/* 3.7.1 */

discr_part	: '(' discr_specs ')'
		;

discr_specs	: discr_spec
		| discr_specs ';' discr_spec
		;

discr_spec	: idents ':' ty_mk .ASSIGN_expr.
		;


/* 3.7.2 */

/*
discr_c		: '(' discr_ascs ')'
		;

discr_ascs	: discr_asc
		| discr_ascs ',' discr_asc
		;

discr_asc	: expr
		| sim_n_choices ARROW_ expr
		;
*/
/* included under 'idx_or_discr_c' */

sim_n_choices	: sim_n
		| sim_n_choices '|' sim_n
		;


/* 3.7.3 */

variant_part	: CASE_ sim_n IS_ ..prag.. variants END_ CASE_ ';'
		  /* Pragmas after 'variants' are in 'cmpons' at end of rhs */
		  /* of 'variant' */
		;

variants	: variant
		| variants variant
		;

variant		: WHEN_ choices ARROW_ cmpons
		;

choices		: choice
		| choices '|' choice
		;

choice		: sim_expr
		| name rng_c
		| sim_expr DBLDOT_ sim_expr
		| OTHERS_
		;


/* 3.8 */

access_ty_def	: ACCESS_ subty_ind
		;


/* 3.8.1 */

incomplete_ty_d	: TYPE_ IDENTIFIER .discr_part. ';'
		;


/* 3.9 */

decl_part	: ..basic_decl_item..
		| ..basic_decl_item.. body ..later_decl_item..
		;

/* A 'body' is the only 'later_decl_item' that is not also a	*/
/* 'basic_decl_item'. It is therefore used as the dividing	*/
/* point between the two lists of decl items.			*/

basic_decl_item	: basic_d
		| rep_cl
		| use_cl
		;

later_decl_item	: body
		| subprg_d
		| pkg_d
		| task_d
		| gen_d
		| use_cl
		| gen_inst
		| error ';'
		;

body		: proper_body
		| body_stub
		;

proper_body	: subprg_body
		| pkg_body
		| task_body
		;


/* 4.1 */

name		: sim_n
		| CHARACTER_LITERAL
		| op_symbol
		| idxed_cmpon
/*		| func_call /* parameterless, as 'sim_n' or 'selected_cmpon'; */
/*			       with parameters, as 'idxed_cmpon' */
/*		| slice /* included under 'idxed_cmpon' */
		| selected_cmpon
		| attribute
		;

sim_n		: IDENTIFIER
		;

prefix		: name
		;


/* 4.1.1 */

idxed_cmpon	: prefix '(' exprs ')'
		;

exprs		: expr
		| sim_expr DBLDOT_ sim_expr
		| IDENTIFIER ARROW_ expr
		/* subprg_call formal parameter association */
		| name rng_c
		| exprs ',' exprs
		;


/* 4.1.2 */

/*
slice		: prefix '(' dscr_rng ')'
		;
*/
/* included under 'idxed_cmpon' */


/* 4.1.3 */

selected_cmpon	: prefix '.' selector
		;

selector	: sim_n
		| CHARACTER_LITERAL
		| op_symbol
		| ALL_
		;


/* 4.1.4 */

attribute	: prefix '\'' attribute_designator
		;
/* This can be an 'attribute', 'idxed_cmpon', 'slice', or 'subprg_call' */

attribute_designator	: sim_n
/*		| sim_n '(' expr ')' /* reduced as 'idxed_cmpon' */
		;


/* 4.3 */

aggr		: '(' choices ARROW_ expr ')'
		  /* a single component aggregate must use named notation */
		| '(' cmpon_ascs ')'
		;

cmpon_ascs	: cmpon_asc ',' cmpon_asc
		| cmpon_ascs ',' cmpon_asc
		;

cmpon_asc	: expr
		| choices ARROW_ expr
		;


/* 4.4 */

expr		: expr AND_ expr
		| expr AND_ THEN_ expr	%prec AND_
		| expr OR_ expr
		| expr OR_ ELSE_ expr	%prec OR_
		| expr XOR_ expr
		| expr '=' expr
		| expr NOTEQL_ expr
		| expr '<' expr
		| expr LTEQ_ expr
		| expr '>' expr
		| expr GTEQL_ expr
		| expr IN_ rng
		| expr NOT_ IN_ rng	%prec IN_
/*		| expr IN_ ty_mk /* included under 'expr IN_ rng' */
/*		| expr NOT_ IN_ ty_mk	%prec IN_ /* included under
'expr NOT_ IN_ rng' */
		| sim_expr
		;

sim_expr	: sim_expr '+' term
		| sim_expr '-' term
		| sim_expr '&' term
		| '+' term
		| '-' term
		| term
		;

term		: term '*' term
		| term '/' term
		| term MOD_ term
		| term REM_ term
		| term EXP_ term
		| ABS_ pri
		| NOT_ pri
		| pri
		;

pri		: NUMERIC_LITERAL
		| NULL_
		| aggr
		| name
		  /* includes CHARACTER_LITERAL and STRING_LITERAL */
		  /* STRING_LITERAL is included as 'op_symbol' */
		| allocator
/*		| func_call /* included under 'name' */
/*		| ty_cnvr /* included under 'name' */
		| qualified_expr
		| '(' expr ')'
		;


/* 4.6 */

/*
ty_cnvr		: ty_mk '(' expr ')'
		;
*/
/* included under 'name' */


/* 4.7 */

qualified_expr	: prefix /* must be a 'ty_mk' */ '\'' '(' expr ')'
		| prefix /* must be a 'ty_mk' */ '\'' aggr
		;


/* 4.8 */

allocator	: NEW_ ty_mk
/*		| NEW_ ty_mk idx_c */
/*		| NEW_ ty_mk discr_c */
		| NEW_ ty_mk idx_or_discr_c
/*		| NEW_ qualified_expr */
		| NEW_ ty_mk '\'' '(' expr ')'
		| NEW_ ty_mk '\'' aggr
		;


/* 5.1 */

seq_of_stmts	: ..prag.. stmt
		| seq_of_stmts stmt
		| seq_of_stmts prag
		;

stmt		: ..label.. sim_stmt
		| ..label.. compound_stmt
		| error ';'
		;

sim_stmt	: null_stmt
		| assignment_stmt
		| exit_stmt
		| return_stmt
		| goto_stmt
		| delay_stmt
		| abort_stmt
		| raise_stmt
		| code_stmt
		| sim_n ';'
		| selected_cmpon ';'
		| idxed_cmpon ';'
/*		| ent_call_stmt /* parameterless, as 'sim_n' or */
/*				 'selected_cmpon'; with parameters, as */
/*				 'idxed_cmpon' */
/*		| procedure_call_stmt /* parameterless, as 'sim_n' or */
/*				 'selected_cmpon'; with parameters, as */
/*				 'idxed_cmpon' */
		;

compound_stmt	: if_stmt
		| case_stmt
		| loop_stmt
		| block_stmt
		| accept_stmt
		| select_stmt
		;

label		: L_LBL_ sim_n R_LBL_
		;

null_stmt	: NULL_ ';'
		;


/* 5.2 */

assignment_stmt	: name ASSIGN_ expr ';'
		;


/* 5.3 */

if_stmt		: IF_ cond THEN_ seq_of_stmts
		  ..ELSIF__cond__THEN__seq_of_stmts..
		  .ELSE__seq_of_stmts.
		  END_ IF_ ';'
		;

cond		: expr
		;


/* 5.4 */

case_stmt	: CASE_ expr IS_ ..prag.. case_stmt_alts END_ CASE_ ';'
		  /* Pragmas after 'case_stmt_alts' are in 'seq_of_stmts' at */
		  /* end of rhs of 'case_stmt_alt' */
		;

case_stmt_alts	: case_stmt_alt
		| case_stmt_alts case_stmt_alt
		;

case_stmt_alt	: WHEN_ choices ARROW_ seq_of_stmts
		;


/* 5.5 */

loop_stmt	: .sim_nC. /* sim_n ':' */
		  .iteration_scheme. LOOP_
		  seq_of_stmts
		  END_ LOOP_ .sim_n. ';'
		;

iteration_scheme: WHILE_ cond
		| FOR_ loop_prm_spec
		;

loop_prm_spec	: IDENTIFIER IN_ .REVERSE. dscr_rng
		;


/* 5.6 */

block_stmt	: .sim_nC. /* sim_n ':' */
		  .DECLARE__decl_part.
		  BEGIN_
		  seq_of_stmts
		  .frame_excptn_handlers.
		  END_ .sim_n. ';'
		;


/* 5.7 */

exit_stmt	: EXIT_ .expanded_n. .WHEN__cond. ';'
		;


/* 5.8 */

return_stmt	: RETURN_ .expr. ';'
		;


/* 5.9 */

goto_stmt	: GOTO_ expanded_n ';'
		;


/* 6.1 */

subprg_d	: subprg_spec ';'
		;

subprg_spec	: PROCEDURE_ IDENTIFIER .fml_part.
		| FUNCTION_  designator .fml_part. RETURN_ ty_mk
		;

designator	: IDENTIFIER
		| op_symbol
		;

op_symbol	: STRING_LITERAL
		;

fml_part	: '(' prm_specs ')'
		;

prm_specs	: prm_spec
		| prm_specs ';' prm_spec
		;

prm_spec	: idents ':' mode ty_mk .ASSIGN_expr.
		;

mode		: .IN.
		| IN_ OUT_
		| OUT_
		;


/* 6.3 */

subprg_body	: subprg_spec IS_ .decl_part.
		  BEGIN_
		  seq_of_stmts
		  .frame_excptn_handlers.
		  END_ .designator. ';'
		;


/* 6.4 */

/*
procedure_call_stmt	: procedure_n .act_prm_part. ';'
		;
*/
/* included under 'name' */

/*
func_call	: func_n .act_prm_part.
		;
*/
/* included under 'name' */

/*
act_prm_part	: '(' prm_asc ...prm_asc.. ')'
		;

prm_asc		: fml_prm ARROW_ act_prm
		| act_prm
		;

fml_prm		: sim_n
		;

act_prm		: expr
		| name
		| ty_mk '(' name ')'
		;
*/


/* 7.1 */

pkg_d		: pkg_spec ';'
		;

pkg_spec	: PACKAGE_ IDENTIFIER IS_
		  ..basic_decl_item..
		  .private_part. END_ .sim_n.
		;

pkg_body	: PACKAGE_ BODY_ sim_n IS_
		  .decl_part.
		  .pkg_body_init.
		  END_ .sim_n. ';'
		;


/* 7.4 */

priv_ty_d	: TYPE_ IDENTIFIER .discr_part. IS_ .LIMITED. PRIVATE_ ';'
		;

defer_const_d	: idents ':' CONSTANT_ ty_mk ';'
		;


/* 8.4 */

use_cl		: USE_ expanded_ns ';'
		;

expanded_ns	: expanded_n
		| expanded_ns ',' expanded_n
		;


/* 8.5 */

renaming_d	: idents ':' ty_mk      RENAMES_ name ';'
		| idents ':' EXCEPTION_ RENAMES_ expanded_n ';'
/* 'idents' in the two above rules must contain only one 'IDENTIFIER' */
		| PACKAGE_ IDENTIFIER   RENAMES_ expanded_n ';'
		| subprg_spec           RENAMES_ name ';'
		;


/* 9.1 */

task_d		: task_spec ';'
		;

task_spec	: TASK_ .TYPE. IDENTIFIER .task_interface.
		;

task_body	: TASK_ BODY_ sim_n IS_ .decl_part.
		  BEGIN_
		  seq_of_stmts
		  .frame_excptn_handlers.
		  END_ .sim_n. ';'
		;


/* 9.5 */

ent_d		: ENTRY_ IDENTIFIER                  .fml_part. ';'
		| ENTRY_ IDENTIFIER '(' dscr_rng ')' .fml_part. ';'
		;

ent_call_stmt	: ..prag.. sim_n ';' /* parameterless */
		| ..prag.. selected_cmpon ';' /* parameterless */
		| ..prag.. idxed_cmpon ';' /* with parameters */
		;

accept_stmt	: ACCEPT_ sim_n .Pent_idx_P..fml_part.
		  .DO__seq_of_stmts__END.sim_n.. ';'
		;

ent_idx		: expr
		;


/* 9.6 */

delay_stmt	: DELAY_ sim_expr ';'
		;


/* 9.7 */

select_stmt	: selec_wait
		| condal_ent_call
		| timed_ent_call
		;


/* 9.7.1 */

selec_wait	: SELECT_ select_alts .ELSE__seq_of_stmts. END_ SELECT_ ';'
		;

select_alts	: select_alt
		| select_alts OR_ select_alts
		;

select_alt	: selec_wait_alt
		| WHEN_ cond ARROW_ selec_wait_alt
		;

selec_wait_alt	: accept_alt
		| delay_alt
		| terminate_alt
		;

accept_alt	: ..prag.. accept_stmt .seq_of_stmts.
		;

delay_alt	: ..prag.. delay_stmt .seq_of_stmts.
		;

terminate_alt	: ..prag.. TERMINATE_ ';' ..prag..
		;


/* 9.7.2 */

condal_ent_call	: SELECT_ ent_call_stmt .seq_of_stmts.
		  ELSE_ seq_of_stmts END_ SELECT_ ';'
		;


/* 9.7.3 */

timed_ent_call	: SELECT_ ent_call_stmt .seq_of_stmts.
		  OR_ delay_alt END_ SELECT_ ';'
		;


/* 9.10 */

abort_stmt	: ABORT_ names ';'
		;

names		: name
		| names ',' name
		;


/* 10.1 */

compilation	: compilation_units
		;

compilation_units	: ..prag..
		| compilation_units compilation_unit
		;

compilation_unit: ..context_cl.. library_unit ..prag..
		| ..context_cl.. secondary_unit ..prag..
		;

library_unit	: subprg_d
		| pkg_d
		| gen_d
		| gen_inst
		| subprg_body
		;

secondary_unit	: library_unit_body
		| subunit
		;

library_unit_body	: pkg_body
/*		| subprg_body /* already contained in 'library_unit' */
		;


/* 10.1.1 */

context_cl	: with_cl
		| context_cl use_cl
		| context_cl prag
		;

with_cl		: WITH_ sim_ns ';'
		;

sim_ns		: sim_n
		| sim_ns ',' sim_n
		;


/* 10.2 */

body_stub	: subprg_spec          IS_ SEPARATE_ ';'
		| PACKAGE_ BODY_ sim_n IS_ SEPARATE_ ';'
		| TASK_    BODY_ sim_n IS_ SEPARATE_ ';'
		;

subunit		: SEPARATE_ '(' expanded_n ')' proper_body
		;


/* 11.1 */

excptn_d	: idents ':' EXCEPTION_ ';'
		;


/* 11.2 */

excptn_handler	: WHEN_ excptn_choices ARROW_ seq_of_stmts
		  /* Pragmas after 'excptn_handler' are in 'seq_of_stmts' at */
		  /* end of rhs */
		;

excptn_choices	: excptn_choice
		| excptn_choices '|' excptn_choice
		;

excptn_choice	: expanded_n
		| OTHERS_
		;


/* 11.3 */

raise_stmt	: RAISE_ .expanded_n. ';'
		;


/* 12.1 */

gen_d		: gen_spec ';'
		;

gen_spec	: gen_fml_part subprg_spec
		| gen_fml_part pkg_spec
		;

gen_fml_part	: GENERIC_ ..gen_prm_d..
		;

gen_prm_d	: idents ':' .IN.OUT.. ty_mk .ASSIGN_expr. ';'
		| TYPE_ IDENTIFIER
		  .discr_part. /* .discr_part. must be empty; added only
				  to resolve a shift/reduce ambiguity */
		  IS_ gen_ty_def ';'
		| priv_ty_d
		| WITH_ subprg_spec ';'
		| WITH_ subprg_spec IS_ BOX_ ';'
		| WITH_ subprg_spec IS_ name ';'
		;

gen_ty_def	: '(' BOX_ ')'
		| RANGE_ BOX_
		| DIGITS_ BOX_
		| DELTA_ BOX_
		| array_ty_def
		| access_ty_def
		;


/* 12.3 */

gen_inst	: PACKAGE_ IDENTIFIER  IS_ NEW_ expanded_n .gen_act_part. ';'
		| subprg_spec          IS_ NEW_ expanded_n .gen_act_part. ';'
		/* the more general 'subprg_spec' is used to avoid conflicts */
		| FUNCTION_ designator IS_ NEW_ expanded_n .gen_act_part. ';'
		;

gen_act_part	: '(' gen_ascs ')'
		;

gen_ascs	: gen_asc
		| gen_ascs ',' gen_asc
		;

gen_asc		: gen_act_prm
		| gen_fml_prm ARROW_ gen_act_prm
		;

gen_fml_prm	: sim_n
		| op_symbol
		;

gen_act_prm	: expr
/*		| name /* included under 'expr' */
/*		| subprg_n /* included under 'expr' */
/*		| ent_n /* included under 'expr' */
/*		| ty_mk /* included under 'expr' */
		;


/* 13.1 */

rep_cl		: ty_rep_cl
		| address_cl
		;

ty_rep_cl	: length_cl
		| enum_rep_cl
		| rec_rep_cl
		;


/* 13.2 */

length_cl	: FOR_ attribute USE_ sim_expr ';'
		;


/* 13.3 */

enum_rep_cl	: FOR_ sim_n USE_ aggr ';'
		;


/* 13.4 */

rec_rep_cl	: FOR_ sim_n /* 'sim_n' must be a 'ty_sim_n' */ USE_
		  RECORD_ ..prag.. .algt_cl.
		  ..cmpon_cl..
		  END_ RECORD_ ';'
		;

algt_cl		: AT_ MOD_ sim_expr ';'
		;

cmpon_cls	: cmpon_cl
		| cmpon_cls cmpon_cl
		| cmpon_cls prag
		;

cmpon_cl	: name AT_ sim_expr RANGE_ rng ';'
		;


/* 13.5 */

address_cl	: FOR_ sim_n USE_ AT_ sim_expr ';'
		;


/* 13.8 */

code_stmt	: prefix /* must be a 'ty_mk' */ '\'' aggr ';'
		;


/*----------------------------------------------------------------------*/

/* The following rules define semantically qualified symbols under more
/* general categories.

/*     ... these have been replaced logically to reduce the number    */
/*         of YACC_ nonterminal "rules"                                */

/* The following rules expand the concatenated constructs and define the */
/* specially added syntactical classes.					 */


/* 2.8 */

.prag_arg_part.	: /* empty */
		| prag_arg_part
		;

..prag..	: /* empty */
		| ..prag.. prag
		;


/* 3.1 */

.ASSIGN_expr.	: /* empty */
		| ASSIGN_ expr
		;

.constrt.	: /* empty */
		| constrt
		;

expanded_n	: IDENTIFIER
		| expanded_n '.' IDENTIFIER
		;
/* 'expanded_n' is used for names that can be written using only selectors */

.rng_c.		: /* empty */
		| rng_c
		;


/* 3.3.1 */

.discr_part.	: /* empty */
		| discr_part
		;


/* 3.3.2 */

idx_or_discr_c	: '(' dscr_rngs_or_discr_ascs ')'
		;

dscr_rngs_or_discr_ascs	: dscr_rng_or_discr_asc
		| dscr_rngs_or_discr_ascs ',' dscr_rng_or_discr_asc
		;

dscr_rng_or_discr_asc	: sim_expr DBLDOT_ sim_expr
/*		| name /* must be an 'attribute' */
		| name rng_c
		| expr /* includes 'name' */
		| sim_n_choices ARROW_ expr
		;


/* 3.7 */

.cmpon_ds.	: /* empty */
		| cmpon_ds
		;


/* 3.9 */

..basic_decl_item..	: /* empty */
		| ..basic_decl_item.. prag
		| ..basic_decl_item.. basic_decl_item
		;

..later_decl_item..	: /* empty */
		| ..later_decl_item.. prag
		| ..later_decl_item.. later_decl_item
		;


/* 5.1 */

..label..	: /* empty */
		| ..label.. label
		;

..ELSIF__cond__THEN__seq_of_stmts..	: /* empty */
		| ..ELSIF__cond__THEN__seq_of_stmts..
		  ELSIF_ cond THEN_ seq_of_stmts
		;

.ELSE__seq_of_stmts.	: /* empty */
		| ELSE_ seq_of_stmts
		;

.sim_nC.	: /* empty */
		| sim_n ':'
		;

.sim_n.		: /* empty */
		| sim_n
		;

.iteration_scheme.	: /* empty */
		| iteration_scheme
		;

.REVERSE.	: /* empty */
		| REVERSE_
		;

.DECLARE__decl_part.	: /* empty */
		| DECLARE_ decl_part
		;

.frame_excptn_handlers.	: /* empty */
		| EXCEPTION_ ..prag.. excptn_handlers
		/* Pragmas after 'excptn_handler' are in 'seq_of_stmts' */
		;

excptn_handlers	: excptn_handler
		| excptn_handlers excptn_handler
		;

.expanded_n.	: /* empty */
		| expanded_n
		;

.WHEN__cond.	: /* empty */
		| WHEN_ cond
		;

.expr.		: /* empty */
		| expr
		;


/* 6.1 */

.fml_part.	: /* empty */
		| fml_part
		;

.IN.		: /* empty */
		| IN_
		;

.decl_part.	: decl_part
		/* 'decl_part' can already be empty */
		;

.designator.	: /* empty */
		| designator
		;


/* 7.1 */

.LIMITED.	: /* empty */
		| LIMITED_
		;

.private_part.	: /* empty */
		| PRIVATE_ ..basic_decl_item..
		;

.pkg_body_init.	: /* empty */
		| BEGIN_
		  seq_of_stmts
		  .frame_excptn_handlers.
		;


/* 9.1 */

.TYPE.		: /* empty */
		| TYPE_
		;

.task_interface.	: /* empty */
		| IS_ ..ent_d.. ..rep_cl.. END_ .sim_n.
		;

..ent_d..	: /* empty */
		| ..ent_d.. prag
		| ..ent_d.. ent_d
		;

..rep_cl..	: /* empty */
		| ..rep_cl.. prag
		| ..rep_cl.. rep_cl
		;


/* 9.5 */

.Pent_idx_P..fml_part.	: .fml_part.
		| '(' ent_idx ')' .fml_part.
		;

.DO__seq_of_stmts__END.sim_n..	: /* empty */
		| DO_ seq_of_stmts END_ .sim_n.
		;

.seq_of_stmts.	: ..prag..
		| seq_of_stmts
		;


/* 10.1.1 */

..context_cl..	: /* empty */
		| ..context_cl.. context_cl
		;


/* 12.1 */

..gen_prm_d..	: /* empty */
		| ..gen_prm_d.. gen_prm_d
		;

.IN.OUT..	: .IN.
		| IN_ OUT_
		;

.gen_act_part.	: /* empty */
		| gen_act_part
		;


/* 13.4 */

.algt_cl.	: /* empty */
		| algt_cl
		;

..cmpon_cl..	: /* empty */
		| ..prag.. cmpon_cls
		;

%%	/* start of programs */

main() {
   yyparse ();
}

yyerror(string)
char *string;
{
   fprintf (stderr, "\n>>>\n>>> %s at line %d near %s.\n>>>\n",
		    string, yylineno, yytext);
}

